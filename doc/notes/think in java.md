<!-- GFM-TOC -->
* [前言](#前言)
* [第 1 章：对象引论](#一、对象引论)
    * [抽象过程](#抽象过程)
    * [每个对象都有一个接口](#每个对象都有一个接口)
    * [每个对象都提供服务](#每个对象都提供服务)
    * [被隐藏的具体实现](#被隐藏的具体实现)
    * [复用具体实现](#复用具体实现)
    * [继承：复用接口](#继承：复用接口)
    * [伴随多态的可互换对象](#伴随多态的可互换对象)
    * [抽象基类和接口](#抽象基类和接口)
    * [对象的创建、使用和生命周期](#对象的创建、使用和生命周期)   
    * [集合（collection）与迭代器（iterator）](#集合（collection）与迭代器（iterator）)
    * [单根继承结构](#单根继承结构)
    * [向下转型（downcasting）与模板/泛型（template/generic）](#向下转型（downcasting）与模板/泛型（template/generic）)
* [第 2 章：一切都是对象](二一切都是对象)
    * [用引用（reference）操纵对象](#用引用（reference）操纵对象)
* [第 3 章：控制程序流](三控制程序流)
    * [自动递增（increment）和递减（decrement） ](#自动递增（increment）和递减（decrement） )
    * [关系操作符](#关系操作符)
* [第 4 章：初始化与清除](四初始化与清除)   
    * [以构造器确保初始化](#以构造器确保初始化)
    * [方法重载](#方法重载)
    * [缺省构造器](#缺省构造器)
    * [this 关键字](#this关键字)
    * [static 的含义 ](#static的含义 )
    * [清除:终结和垃圾回收](#清除:终结和垃圾回收)
    * [finalize()用途何在](#finalize()用途何在)
    * [终结条件](#终结条件)

# 前言
* Java 上体现出的 Sun 公司的设计目标：为
程序员降低复杂度。
* 你需要在头脑中创建一个模型，用于加强对这种语言的深
入理解；如果你遇到了疑问，你就能够将它反馈给你的模型并推断出答案。

# 一、对象引论   
## 抽象过程
面向对象编程思想的实质：程序可以通过添加新类型的
对象使自身适用于某个特定问题。   


面向对象程序设计方式：
* 万物皆为对象。
* 程序是对象的集合，它们彼此通过发送消息来调用对方。
_这里的可以把消息想象为调用请求_
* 每个对象都拥有由其它对象所构成的存储。
* 每个对象都拥有其类型（Type）。
* 某一特定类型的所有对象都可以接收(Receive)同样的消息。 _可替代性_



## 每个对象都有一个接口
什么是**类**:具有相同特性（数据元素）和行为（功能）的对象集合。 

面向对象方法并不是仅局限于构件仿真程序。无论你是否同意任何程序都是你所设计的系统
的一个仿真的观念，面向对象技术确实可以将大量的问题降解为一个简单的解决方案。       

每个对象都只能满足某些请求，
这些请求由对象的接口（Interface）所定义，决定接口的便是类型（Type）。


## 每个对象都提供服务
当你正是如开发或理解一个程序设计时，最好的方法之一就是将对象想象为“服务提供者
（Service Provider）”    

## 被隐藏的具体实现
将程序开发人员按照角色分为类创建者（class creator，那些创建新数据类型的程序员）和客
户端程序员（client programmer，那些在其应用中使用数据类型的类消费者）是大有裨益的。 _这里我感觉可以理解为框架的作者负责编写类，只暴露必须的部分。调用api的程序员，不会接触到内部隐藏的脆弱部分。_

类的内部设定边界关键字：
* public：表示紧随其后的元素对任何人都是可用的。
* private：这个关键字表示除
类型创建者和该类型的内部方法之外的任何人都不能访问的元素。 
* protected：仅在于继承类（Inheriting class）可以访问 protected
成员。
* 缺省（default）:“包访问权限（package access）”

## 复用具体实现
新的类可以由任意数量、任意类型的其它对象以任意可以实现新的类中想要的功能的方式所组成。因为你在使用现有的类合成新的类，所以这种概念被称为组合（composition）。

在建立新类时，当你选择是使用继承还是组合时,你应该首先考虑组合，因为它更加简单而灵活。

## 继承：复用接口

在创建了一个类之后，即使另一个新类与其具有相似的功能，你还是得重新创建一个新类。如果我们能够以现有的类为基础，复制它，然后通过添加和修改这个副本来创建新类那就要好得多了。通过继承便可以达到这样的效果，不过也有例外，当源类（被称为基类( base class)、超类(super class)或父类(parent class)）发生变动时，被修改的“副本”（被称为导出类(derived class)、继承类(inherited class)或子类(subclass, childclass)）也会反映出这些变动。  

当你继承了现有类型之后，也就创建了新的类型，这个类型含有所有现有类型的成员（private 被隐藏了而已），最重要的是复制了基类的接口，发送给基类的消息也可以发送给导出类(子类)。 由于我们通过可发送消息的类型可知类的类型，所以这也就意味着导出类与基类具有相同的类型。在前面的例子中，“一个圆形也就是一个几何形状”。通过继承而产生的**类型等价**（type equivalence）是理解面向对象程序设计方法内涵的重要门槛。

**重载**：使导出类和基类之间产生差异的方法是改变现有基
类的方法的行为。

## 是一个（is-a）与像是一个（is-like-a）关系

该只重载基类的方法，导出类对象可以完全替代一个基类对象。这可以被视为“纯粹替代（pure substitution）”，通常称之为“替代法则（substitution principle）”。   

在判断是否使用组合和继承的时候，如果是一种`is-a`的关系，使用继承比较理想。

## 伴随多态的可互换对象

Q：如果你不需要知道哪一段代码会
被执行，那么当你添加新的子类型时，不需要更改方法调用的代码，就能够执行不同的代码。
因此，编译器无法精确地了解哪一段代码将会被执行，那么它该怎么办呢？    

A：面向对象程序设计的最重要的妙诀：在OOP中，程序直到运行时刻才能确定代码的地址。为了解决这个问题OOP采用了**后期绑定**。编译器只需要确定调用方法存在，并且检查调用的参数和返回值的类型就行了。

我们把将导出类看作是它的基类的过程称为“向上转型（upcasting）”。“转型（cast）”这个名称的灵感来自于模型铸造的塑模动作，而“向上（up）”这个词来源于继承图的典型布局方式：通常基类在顶部，而导出类在其下部散开。因此，转型为一个基类就是在继承图中向上移动，即“向上转型（upcasting）”

![](../images/upcasting.png)

## 抽象基类和接口
* 抽象类:你不希望任何人创
建基类的实际对象，而只是希望他们将对象向上转型到基类。
* 抽象方法:作为所有导出类都具有的接口方法。
* 接口:提供了接口与实现的完美分离。  


## 对象的创建、使用和生命周期
垃圾回收器（garbage collector）:它可以自动发现对象何时不再被使用，并继而销毁它。

## 集合（collection）与迭代器（iterator）

容器:创建另一种对
象的类型。解决这个特定问题的新的对象类型持有对其它对象的引用。

## 单根继承结构

Java的终极基类:Object

## 向下转型（downcasting）与模板/泛型（template/generic）

* 向下转型（downcasting）:向下转型为更具体的类型。  
* 参数化类型:是编译器可以自动定制作用
于特定类型之上的类。

# 二、一切都是对象  

## 用引用（reference）操纵对象


## 存储到什么地方

* 寄存器（register）:这是最快的存储区。
* 堆栈（stack）：创建程序时，Java 编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成相应的代码，以便上下移动堆栈指针。
* 堆（heap）：一种通用性的内存池（也存在于 RAM 区），用于存放所有的 Java 对象。
* 静态存储（static storage）：静态存储里存放程序运行时一直存在的数据。
* 常量存储（constant storage）：常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。
* 非 RAM 存储（non-RAM storage）：如果数据完全存活于程序之外，“流对象”，“持久化对象”。   

## 特例：基本类型（primitive type）
基本类型:因为特别小，用new不是很有效，创建一个拥有值的变量。

## 域（field）和方法（method）

* 域（field，有时被称作数据成员（data 
member））    
* 方法（有时被称作成员函数（member function））

## 基本成员默认值 
千万要小心：当变量作为一个类的成员使用时，Java 才确保给定其默认值，以确保那些是基本类型的成员变量得到初始化。


## 名字可视性（Name visibility） 
为了给一个类库生成不会与其它名字
混淆的名字，Java 采用了与 Internet 域名相似的指定符。 



# 三、控制程序流

## 使用 Java 操作符 

## 自动递增（increment）和递减（decrement） 
对于前缀递增和前缀递减（如  ++a  或  --a  ），会先执行运
算，再生成值。而对于后缀递增和后缀递减（如 a++或 a--），会先生成值，再执行运算。

## 关系操作符

* ==和!=： 比较的就是对象的引用
* equals()：比较两个对象的实际内容是否相同。

# 四、初始化与清除

## 以构造器确保初始化

命名方法:
* 取的名字会与成员名称相冲突
* 必须让编译器知道应该调用哪个方法

## 方法重载  
* 缺省构造器
* 有参构造器

方法接受较小的基本类型作为参数时，如果传入参数较大，就需要进行参数转换。
```java
public class PrimitiveOverloading {
    void  f1 (short x){
        System.out.println("f1 (short x)");
    }

    public static void main(String[] args) {
        PrimitiveOverloading primitiveOverloading = new PrimitiveOverloading();
        int a = 111;
        primitiveOverloading.f1((short) a);
    }
}

```

## 缺省构造器

缺省构造器:没有形式参数。作用:创建一个"基本对象"。

如果你写的类没有构造器，编译器会自动帮你创建一个缺省构造器。

## this关键字

编译器暗自把所操作对象的引用作为第一个参数传入f()。
`Banana.f(a,1)`
但是你不能这样书写。
因为这个引用是偷偷传入的，所以这里就提供了一个特定的关键字`this`。

1. 如果在方法内部调用同一个类的方法，就不必使用`this`直接调用即可。
2. 如果需要明确指出当前对象的引用的时候，才需要使用`this`

```java
public class Leaf {
      int i = 0;
      Leaf increment() {
i++;
        return this;
      }
}
```

## static的含义 

静态方法: 没有`this`的方法。

Java禁止全局函数，但是你可以使用静态方法访问其他静态方法  
和静态字段。

## 清除:终结和垃圾回收

垃圾回收器:只知道释放那些经由`new`分配的内存，所以对于不是`new`分配的
特殊内存就无法释放。所以Java允许你在类中定义一个叫做`finalize()`的方法
，一旦垃圾回收器准备好释放对象占用的空间时，首先调用这个方法，并且在下一次垃圾回收动作发生时，才会真正回收内存。

`finalize() ` :在垃圾回收时刻做一些重要的清除工作。
## finalize()用途何在?

* 对象可能不被垃圾回收
* 垃圾回收不等于析构
* 垃圾回收只和内存有关，垃圾回收器存在的意义就是为了回收不再使用的内存。

垃圾回收和终结都不保证一定会发生，如果java虚拟机并未面临内存耗尽，就不会浪费时间在垃圾回收恢复内存上。

## 终结条件

`finalize()`的价值就是用来发现对象是否存在没有被适当清除的部分。

```java
public class Book {

    boolean checkOut = false;

    Book(boolean checkOut) {
        this.checkOut = checkOut;
    }

    void checkIn() {
        checkOut = false;
    }

    public void finalize(){
        if (checkOut) {
            System.out.println("Error: checked out");
        }
    }
}
public class TerminationCondition {
    public static void main(String[] args) {
        Book book = new Book(true);
        book.checkIn();
        new Book(true);
        System.gc();
    }
}

```

## 垃圾回收器如何工作

Java的"堆指针"可以简单的移动到尚未分配的区域。

垃圾回收器工作时，一面回收空间，一面使堆中的对象紧凑排列，这样堆指针就能够更容易的移动到传送带开始的地方。

* 引用计数: 一种简单但是很慢的垃圾回收技术，每个对象都含有一个引用计数器，当引用连接至对象时，引用计数加1，当引用离开作用域或被置为`null`的时候，引用计数减1。
    * 开销不大，但是在整个程序生命周期内会持续的开销。
    * 存在循环引用时候，出现"对象应该被回收，但是引用计数不为0"
* 基于DFS垃圾回收技术:对于任何活的对象，一定能够在堆栈或者是静态存储区中找到他的引用。从堆栈和静态存储区的所有引用开始遍历，追踪对象，然后是这个对象的引用，反复如此，就能够得到活的对象。循环引用的对象根本不会被发现。 

Java 虚拟机 将采用一种"自适应"的垃圾回收技术。


"停止"----"复制":暂停程序运行，将存活对象复制到另外一个堆，没有复制的都是垃圾。
搬运的同时，所有指向对象的引用都必须修正，位于堆和静态存储区的引用可以直接被修正。
    * 需要两个堆，按需从堆分配几块较大的内存，复制动作发生在大块内存之间。
    * 程序稳定没有垃圾时，切换到"标记----清扫"模式，在垃圾少的时候速度很快。
2. "标记----清扫":DFS遍历所有活的对象，并设置标记，结束后，没有标记的对象释放，但是剩下的堆空间是不连续的，所以得重新整理对象。
3. "停止----复制":当可用内存较低时候，垃圾回收器被激活，发生同时停止程序。

Java虚拟机的内存分配单位是"块"，如果对象较大就会独立占用一个块。
块具有相应的"代数"记录是否存活。
Java虚拟机会监控垃圾回收器的效率，如果效率低就采用"标记----清扫"，如果内存中碎片较多就会采用"停止----复制"，这样的自适应策略。