<!-- GFM-TOC -->
* [前言](#前言)
* [第 1 章：对象引论](#一对象引论)
    * [抽象过程](#抽象过程)
    * [每个对象都有一个接口](#每个对象都有一个接口)
    * [每个对象都提供服务](#每个对象都提供服务)
    * [被隐藏的具体实现](#被隐藏的具体实现)
    * [复用具体实现](#复用具体实现)
    * [继承：复用接口](#继承：复用接口)
* [第 2 章：一切都是对象](二一切都是对象)
* [第 3 章：控制程序流](三控制程序流)



# 前言
* Java 上体现出的 Sun 公司的设计目标：为
程序员降低复杂度。
* 你需要在头脑中创建一个模型，用于加强对这种语言的深
入理解；如果你遇到了疑问，你就能够将它反馈给你的模型并推断出答案。

# 一、对象引论   
## 抽象过程
面向对象编程思想的实质：程序可以通过添加新类型的
对象使自身适用于某个特定问题。   


面向对象程序设计方式：
* 万物皆为对象。
* 程序是对象的集合，它们彼此通过发送消息来调用对方。
_这里的可以把消息想象为调用请求_
* 每个对象都拥有由其它对象所构成的存储。
* 每个对象都拥有其类型（Type）。
* 某一特定类型的所有对象都可以接收(Receive)同样的消息。 _可替代性_



## 每个对象都有一个接口
什么是**类**:具有相同特性（数据元素）和行为（功能）的对象集合。 

面向对象方法并不是仅局限于构件仿真程序。无论你是否同意任何程序都是你所设计的系统
的一个仿真的观念，面向对象技术确实可以将大量的问题降解为一个简单的解决方案。       

每个对象都只能满足某些请求，
这些请求由对象的接口（Interface）所定义，决定接口的便是类型（Type）。


## 每个对象都提供服务
当你正是如开发或理解一个程序设计时，最好的方法之一就是将对象想象为“服务提供者
（Service Provider）”    

## 被隐藏的具体实现
将程序开发人员按照角色分为类创建者（class creator，那些创建新数据类型的程序员）和客
户端程序员（client programmer，那些在其应用中使用数据类型的类消费者）是大有裨益的。 _这里我感觉可以理解为框架的作者负责编写类，只暴露必须的部分。调用api的程序员，不会接触到内部隐藏的脆弱部分。_

类的内部设定边界关键字：
* public：表示紧随其后的元素对任何人都是可用的。
* private：这个关键字表示除
类型创建者和该类型的内部方法之外的任何人都不能访问的元素。 
* protected：仅在于继承类（Inheriting class）可以访问 protected
成员。
* 缺省（default）:“包访问权限（package access）”

## 复用具体实现
新的类可以由任意数量、任意类型的其它对象以任意可以实现新的类中想要的功能的方式所组成。因为你在使用现有的类合成新的类，所以这种概念被称为组合（composition）。

在建立新类时，当你选择是使用继承还是组合时,你应该首先考虑组合，因为它更加简单而灵活。

## 继承：复用接口

在创建了一个类之后，即使另一个新类与其具有相似的功能，你还是得重新创建一个新类。如果我们能够以现有的类为基础，复制它，然后通过添加和修改这个副本来创建新类那就要好得多了。通过继承便可以达到这样的效果，不过也有例外，当源类（被称为基类( base class)、超类(super class)或父类(parent class)）发生变动时，被修改的“副本”（被称为导出类(derived class)、继承类(inherited class)或子类(subclass, childclass)）也会反映出这些变动。  

当你继承了现有类型之后，也就创建了新的类型，这个类型含有所有现有类型的成员（private 被隐藏了而已），最重要的是复制了基类的接口，发送给基类的消息也可以发送给导出类(子类)。 由于我们通过可发送消息的类型可知类的类型，所以这也就意味着导出类与基类具有相同的类型。在前面的例子中，“一个圆形也就是一个几何形状”。通过继承而产生的**类型等价**（type equivalence）是理解面向对象程序设计方法内涵的重要门槛。

**重载**：使导出类和基类之间产生差异的方法是改变现有基
类的方法的行为。
# 二、一切都是对象

# 三、控制程序流